"""
Expression trees

An expression tree is tree constructed recursively of lists of lists.

Internal vertices are lists describing expressions.  A list like
    [ oper, expr_1, expr_2, ..., expr_n ]
indicates performing the operation on the values of the 0 or more
sub expressions.  Think of it as making a function call:
    oper(expr_1, expr_2, ..., expr_n)

In the case of binary operations like +, *, -, / we think of them
as in the form ( expr_1 oper expr_2 )

Leaf vertices are non-lists representing numbers or possibly variables.
A leaf could be something like: 42, or 'x'

"""

# NOTE - THE MORNING PROBLEM TASK IS IDENTIFIED IN THE CODE BELOW BY
# YOUR TASK HERE

from structviz import StructViz

def update_dot(v, obj, basename, style='compact'):
    file_name = basename + '.dot'
    f = open(file_name, "w", encoding="utf-8")
    v.analyze_struct(obj)
    if style == 'compact':
        rep = v.gen_compact_dot_desc()
    else:
        rep = v.gen_detailed_dot_desc()
    f.write(rep)
    f.close()

    # Enable this to generate png
    if False:
        import subprocess
        subprocess.call(["dot", "-Tpng", file_name, "-O"])


def is_number(v):
    """
    Returns True if v is a number-like thing
    """
    return type(v) in (int, float)

def is_internal(tree):
    """
    Returns True if tree is an internal expression node in the tree.
    """
    return type(tree) is list

# give us the string rep of tree, now with arbitrary numbers of
# expression arguments.
def unparse(tree):
    """
    unparse(tree) generates a string that looks like the expression
    that corresponds to the tree.  We handle binary operations by
    putting the operator in the middle of the two arguments.  Otherwise
    we make the expression look like a function call.

    >>> unparse(42)
    '42'

    >>> exp = [ '*', ['+', 1, 2 ], ['+', 3, 4 ] ]
    >>> unparse(exp)
    '((1 + 2) * (3 + 4))'

    >>> exp = [ '*', ['?', 1], ['+', 3, 4 ] ]
    >>> unparse(exp)
    '((? 1) * (3 + 4))'

    >>> exp = [ 'f', 42, 12, ['+', 1, 2] ]
    >>> unparse(exp)
    'f(42, 12, (1 + 2))'

    """
    if is_number(tree):
        return str(tree)

    if is_internal(tree):

        # Handle special case of binary operations
        if len(tree) == 3:
            (oper, left, right) = tree

            return "({} {} {})".format(
                unparse(left),
                oper,
                unparse(right) )

        # YOUR TASK HERE for '?' and 'f' operations
    if tree[0] == 'f':
        (left, mid, right) = tree[1:4]
        return "f({}, {}, {})".format(
            unparse(left),
            unparse(mid),
            unparse(right) )
    if '?' == tree[0]:
        (left,right) = tree
        return "({} {})".format(
            '?',
            unparse(right) )
    return str(None)

def to_postfix(tree):
    """
    Convert the tree into a postfix (reverse Polish) list of
    values and operations.

    >>> exp = [ '*', ['+', 1, 2 ], ['+', 3, 4 ] ]
    >>> to_postfix(exp)
    [1, 2, '+', 3, 4, '+', '*']

    >>> exp = [ 'f', 42, 12, ['+', 1, 2] ]
    >>> to_postfix(exp)
    [42, 12, 1, 2, '+', 'f']

    >>> exp = [ '*', ['?', 1], ['+', 3, 4 ] ]
    >>> to_postfix(exp)
    [1, '?', 3, 4, '+', '*']

    >>> exp = [ 'f', ['+', 3, 4 ], ['?', 1], ['+', 3, 4 ] ]
    >>> [3, 4, '+', 1, '?', 3, 4, '+', 'f']
    [3, 4, '+', 1, '?', 3, 4, '+', 'f']

    """
    if is_number(tree):
        # The simplest non-trivial postfix is a list of 1 value.
        return [ tree ]

    if is_internal(tree):
        # Put all the argument expressions first, then the oper
        oper = tree[0]
        args = tree[1:]

        # we want to do this:
        # args_list = to_postfix(expr_1) + ... + to_postfix(expr_n) + [oper]
        # where the + is list concatenation.

        args_list = []
        for a in args:
            args_list.extend(to_postfix(a))
        args_list.append(oper)

        return args_list

    return []

def eval_postfix(postfix, stack):
    """
    Evaluate a postfix expression.

    Inputs:
        postfix is a list containing a postfix expression, perhaps
        generated by to_postfix.

        stack is an initial stack prior to evaluating postfix.  It
        is updated as a result of the evaluation,

    Side effects::
        stack is modified.

    Returns:
        stack - so you can compose evaluations easily

    You normally call this with an empty stack.

    >>> exp = [ '*', ['+', 1, 2 ], ['+', 3, 4 ] ]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [21]

    >>> exp = [ '/', 4, 2]
    >>> pf = to_postfix(exp)
    >>> [ 2 ] == eval_postfix(pf, [])
    True

    >>> exp = [ '-', 2, 4]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [-2]

    >>> exp = [ '%', 7, 2]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [3, 1]

    >>> exp = [ '?', 0 ]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [0]

    >>> exp = [ '?', -12 ]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [-1]

    >>> exp = [ '?', 42 ]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [1]

    >>> exp = ['f', 0, 1, 2]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [1]

    >>> exp = ['f', -1, 1, 2]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [1]

    >>> exp = ['f', 3, 1, 2]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [2]


    These next two look weird, and do not unparse properly, but are for
    evaluation! They both compute div mod of 7 and 2.  The first keeps
    only div on the stack. The second keeps only mod on the stack.

    >>> exp = ['f', 0, ['%', 7, 2]]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [3]

    >>> exp = ['f', 1, ['%', 7, 2]]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [1]

    """

    for e in postfix:

        # Push argument onto the stack
        if is_number(e):
            stack.append(e)
            continue

        # Otherwise we are looking at an operation.  So pop the right
        # number of arguments off the stack, perform the operation, and
        # put the results back on the stack.

        # YOUR TASK HERE
        # ADD the % operation which computes the div and mod of the
        # top two items on the stack and replaces them with div and mod
        # on the stack.

        # ADD the ? operation which computes the sgn() of the top of
        # the stack.  sgn(x) = 0 if x = 0, -1 if x < 0, +1 if x > 0

        # ADD the function f(x, y, z) that
        # is y if x <= 0, and is z if x > 0

        if e in ('+', '*', '/', '-', '%'):
            # binary operation
            rval = stack.pop()
            lval = stack.pop()
            if e == '+':
                stack.append(lval + rval)
            elif e == '*':
                stack.append(lval * rval)
            elif e == '-':
                stack.append(lval - rval)
            elif e == '/':
                stack.append(lval / rval)
            elif e == '%':
                y = lval//rval
                x = lval%rval
                stack.append(y)
                stack.append(x)
                # print(stack)
            continue

        if e in ('?'):
            x = stack.pop()
            if x > 0:
                stack.append(1)
            if x == 0:
                stack.append(0)
            if x < 0:
                stack.append(-1)
            continue

        if e in ('f'):
            # ADD the function f(x, y, z) that
            # is y if x <= 0, and is z if x > 0
            # print(stack)
            z = stack.pop()
            y = stack.pop()
            x = stack.pop()
            # print([x,y,z])
            if x > 0:
                stack.append(z)
            elif x <= 0:
                stack.append(y)
            # return eval_postfix(, stack)
            continue

    return stack


def simple_test():
    exp = [ '*', ['+', 1, 2 ], ['+', 3, 4 ] ]
    postfix = to_postfix(exp)
    print(postfix)
    result = eval_postfix(postfix, [])
    print(result)

def main():
    """
    Read in lines, each line containing a python expression that when
    evaluated will construct an expression tree.  For example the line
        [ '*', ['+', 1, 2 ], ['+', 3, 4 ] ]
    Then perform some operations on it, as detailed below.
    """

    v = StructViz()

    for line in sys.stdin:
        # read in expression tree
        line = line.strip()
        if line == "":
            continue

        try:
            exp_tree = eval(line)
        except:
            print("Bad tree def:{}:" .format(line))
            continue

        print("input tree:", exp_tree)
        update_dot(v, exp_tree, "expression-tree")
        print("unparse:", unparse(exp_tree))
        postfix = to_postfix(exp_tree)
        print("postfix:", postfix)

        # protect against evaluate dying
        try:
            result = eval_postfix(postfix, [])
        except:
            result = "Error"
        print("eval:", result)

def _test():
    import doctest
    doctest.testmod()


if __name__ == "__main__":
    """
    Doctest non-module execution
      python3 expr.py --test

    Run doctests if the --test argument is in command line arguments
    when run as a main program.

    Otherwise, run as a normal program.
    """

    import sys
    if "--test" in sys.argv:
        print("Running doctests")
        _test()
        exit()

    main()
