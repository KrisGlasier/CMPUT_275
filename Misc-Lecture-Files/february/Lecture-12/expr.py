"""
Expression trees

An expression tree is tree constructed recursively of lists of lists.

Internal vertices are lists describing expressions.  A list like
    [ oper, expr_1, expr_2, ..., expr_n ]
indicates performing the operation on the values of the 0 or more
sub expressions.  Think of it as making a function call:
    oper(expr_1, expr_2, ..., expr_n)

In the case of binary operations like +, *, -, / we think of them 
as in the form ( expr_1 oper expr_2 )

Leaf vertices are non-lists representing numbers or possibly variables.  
A leaf could be something like: 42, or 'x'

"""

from structviz import StructViz

def update_dot(v, obj, basename, style='compact'):
    file_name = basename + '.dot'
    f = open(file_name, "w", encoding="utf-8")
    v.analyze_struct(obj)
    if style == 'compact':
        rep = v.gen_compact_dot_desc()
    else:
        rep = v.gen_detailed_dot_desc()
    f.write(rep)
    f.close()

    # Enable this to generate png
    if False:
        import subprocess
        subprocess.call(["dot", "-Tpng", file_name, "-O"])


def is_number(v):
    """
    Returns True if v is a number-like thing
    """
    return type(v) in (int, float)

def is_internal(tree):
    """
    Returns True if tree is an internal expression node in the tree.
    """
    return type(tree) is list

# give us the string rep of tree, now with arbitrary numbers of 
# expression arguments.
def unparse(tree):
    """
    unparse(tree) generates a string that looks like the expression
    that corresponds to the tree.  We handle binary operations by 
    putting the operator in the middle of the two arguments.  Otherwise
    we make the expression look like a function call.

    >>> unparse(42)
    '42'

    >>> exp = [ '*', ['+', 1, 2 ], ['+', 3, 4 ] ]
    >>> unparse(exp)
    '( ( 1 + 2 ) * ( 3 + 4 ) )'

    >>> exp = [ 'f', 42, 12, ['+', 1, 2] ]
    >>> unparse(exp)
    'f(42, 12, ( 1 + 2 ))'

    """
    if is_number(tree):
        return str(tree)

    if is_internal(tree):

        # Handle special case of binary operations
        if len(tree) == 3:
            (oper, left, right) = tree

            return "( {} {} {} )".format(
                unparse(left),
                oper,
                unparse(right) )

        # Other cases look like function calls
        # YOUR CODE GOES HERE

    return str(None)

def to_postfix(tree):
    """
    Convert the tree into a postfix (reverse Polish) list of
    values and operations.

    >>> exp = [ '*', ['+', 1, 2 ], ['+', 3, 4 ] ]
    >>> to_postfix(exp)
    [1, 2, '+', 3, 4, '+', '*']

    >>> exp = [ 'f', 42, 12, ['+', 1, 2] ]
    >>> to_postfix(exp)
    [42, 12, 1, 2, '+', 'f']

    """
    if is_number(tree):
        # The simplest non-trivial postfix is a list of 1 value.
        return [ tree ]

    if is_internal(tree):
        # Put all the argument expressions first, then the oper
        oper = tree[0]
        args = tree[1:]

        # we want to do this:
        # args_list = to_postfix(expr_1) + ... + to_postfix(expr_n) + [oper]
        # where the + is list concatenation.

        args_list = []
        for a in args:
            args_list.extend(to_postfix(a))
        args_list.append(oper)

        return args_list

    return [] 

def eval_postfix(postfix, stack):
    """
    Evaluate a postfix expression.

    Inputs:
        postfix is a list containing a postfix expression, perhaps
        generated by to_postfix.

        stack is an initial stack prior to evaluating postfix.  It
        is updated as a result of the evaluation,

    Side effects::
        stack is modified.

    Returns:
        stack - so you can compose evaluations easily

    You normally call this with an empty stack.
    
    >>> exp = [ '*', ['+', 1, 2 ], ['+', 3, 4 ] ]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [21]

    >>> exp = [ '/', 4, 2]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [2]

    >>> exp = [ '-', 4, 2]
    >>> pf = to_postfix(exp)
    >>> eval_postfix(pf, [])
    [-2]

    """
    
    for e in postfix:

        # Push argument onto the stack
        if is_number(e):
            stack.append(e)
            continue

        # Otherwise we are looking at an operation.  So pop the right 
        # number of arguments off the stack, perform the operation, and
        # put the results back on the stack.

        # ADD the - and / operations
        # ADD the function f(x, y, z) that returns y if x <= 0, and
        #   returns z if x > 0

        if e in ('+', '*'):
            # binary operation
            rval = stack.pop()
            lval = stack.pop()
            if e == '+':
                stack.append(lval + rval)
            elif e == '*':
                stack.append(lval * rval)

            # YOU NEED CODE HERE
            continue

        # AND HERE TO HANDLE f
                
    return stack


def simple_test():
    exp = [ '*', ['+', 1, 2 ], ['+', 3, 4 ] ]
    postfix = to_postfix(exp)
    print(postfix)
    result = eval_postfix(postfix, [])
    print(result)

def main():
    """
    Read in lines, each line containing a python expression that when
    evaluated will construct an expression tree.  For example the line
        [ '*', ['+', 1, 2 ], ['+', 3, 4 ] ]
    Then perform some operations on it, as detailed below.
    """

    v = StructViz()

    for line in sys.stdin:
        # read in expression tree
        line = line.strip()
        if line == "":
            continue

        try:
            exp_tree = eval(line)
        except:
            print("Bad tree def:{}:" .format(line))
            continue

        print("input tree:", exp_tree)
        update_dot(v, exp_tree, "expression-tree")
        print("unparse:", unparse(exp_tree))
        postfix = to_postfix(exp_tree)
        print("postfix:", postfix)
        
        # protect against evaluate dying
        try:
            result = eval_postfix(postfix, [])
        except:
            result = "Error"
        print("eval:", result)

def _test():
    import doctest
    doctest.testmod()


if __name__ == "__main__":
    """
    Doctest non-module execution
      python3 expr.py --test

    Run doctests if the --test argument is in command line arguments
    when run as a main program.

    Otherwise, run as a normal program.
    """

    import sys
    if "--test" in sys.argv:
        print("Running doctests")
        _test()
        exit()

    main()
